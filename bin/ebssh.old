#!/bin/sh

cleanup()
{
  local EC
  [ -z "$1" ] && EC=0
  [ -n "$1" ] && EC=$1
  rm -f $ENVLIST $SSHCONFIG
  exit $EC
}

usage()
{
  local EC
  [ -z "$1" ] && EC=0
  [ -n "$1" ] && EC=$1
  if [ "$(basename $0)" = "ebssh" ]
  then
    echo "usage: $(basename $0) [<ssh_args>] <eb_env> [command]" >&2
  elif [ "$(basename $0)" = "ebscp" ]
  then
    echo "usage: $(basename $0) [<scp_args>] { <eb_env>:file file | file <eb_env>:file }" >&2
  fi
  if [ -r "$ENVLIST" ]
  then
    echo >&2
    echo "available eb environments:" >&2
    cat $ENVLIST >&2
  fi
  cleanup $EC
}

trap cleanup INT QUIT TERM KILL

for CMD in aws jq scp sed ssh
do
  which $CMD >/dev/null 2>&1
  RC=$?
  if [ $RC -ne 0 ]
  then
    echo "$CMD command not on PATH" >&2
    cleanup $RC
  fi
done

aws --output json iam get-user >/dev/null 2>&1
RC=$?
if [ $RC -ne 0 ]
then
  echo "error executing aws iam get-user command" >&2
  echo "check your aws credentials config" >&2
  cleanup $RC
fi

ENVLIST=$( mktemp /tmp/tmp.XXXXXXXXXX )

aws \
  --output json \
  elasticbeanstalk describe-environments \
  | jq --raw-output '.Environments[].EnvironmentName' \
  | sort > $ENVLIST
RC=$?
if [ $RC -ne 0 ]
then
  echo "error getting eb environment list" >&2
  cleanup $RC
fi

[ $# -eq 0 ] && usage

for ARG in "$@"
do
  if [ "$(basename $0)" = "ebssh" ]
  then
    echo -n "$ARG" \
      | egrep -q '^[a-z]+-[a-z0-9]+$' \
      && ENVIRONMENT="$ARG"
  elif [ "$(basename $0)" = "ebscp" ]
  then
    echo -n "$ARG" \
      | egrep -q '^[a-z]+-[a-z0-9]+:' \
      && ENVIRONMENT=$( echo -n "$ARG" | cut -f1 -d: )
  fi
done

[ -n "$ENVIRONMENT" ] || usage

grep -q -x $ENVIRONMENT $ENVLIST
RC=$?
if [ $RC -ne 0 ]
then
  echo "allowed eb environments are:" >&2
  cat $ENVLIST >&2
  cleanup $RC
fi

APPLICATION="$( echo -n "$ENVIRONMENT" | cut -f1 -d- )"
BASTIONHOST=${APPLICATION}-bastion.catalyst.harvard.edu
# user names on bastion hosts are the same as iam user names
BASTIONUSER="$( aws --output json iam get-user | jq --raw-output '.User.UserName' )"
# todo: better way to handle devXX environments
PRIVKEY=$HOME/.ssh/$( echo -n $ENVIRONMENT | sed 's~-dev.*~-dev~' ).pem

if [ ! -r "$PRIVKEY" ]
then
  echo "$PRIVKEY isn't readable" >&2
  cleanup 1
fi

PRIVIP=$( aws \
            --output json \
            ec2 describe-instances \
            --filters Name=instance-state-name,Values=running Name=tag:elasticbeanstalk:environment-name,Values=$ENVIRONMENT \
            | jq --raw-output '.Reservations[0].Instances[0].PrivateIpAddress' )
RC=$?
if [ $RC -ne 0 -o "$PRIVIP" = "null" ]
then
  echo "error getting private ip for eb environment $ENVIRONMENT" >&2
  cleanup $RC
fi

SSHCONFIG=$( mktemp /tmp/tmp.XXXXXXXXXX )

cat <<EOF > $SSHCONFIG
Host *
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
    CheckHostIP no
Host ${APPLICATION}-bastion
    HostName $BASTIONHOST
    User $BASTIONUSER
Host $ENVIRONMENT
    ProxyCommand ssh -F $SSHCONFIG ${APPLICATION}-bastion nc $PRIVIP 22
    IdentityFile $PRIVKEY
    User ec2-user
EOF

ssh \
  -F $SSHCONFIG \
  -o ConnectTimeout=5 \
  ${APPLICATION}-bastion \
  : \
  >/dev/null 2>&1
RC=$?
if [ $RC -ne 0 ]
then
  echo "couldn't connect to ${APPLICATION}-bastion" >&2
  cleanup $RC
fi

if [ "$(basename $0)" = "ebssh" ]
then
  ssh -F $SSHCONFIG -t "$@"
elif [ "$(basename $0)" = "ebscp" ]
then
  scp -F $SSHCONFIG "$@"
fi

cleanup $?
